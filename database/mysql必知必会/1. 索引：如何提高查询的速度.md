## 索引是什么？

如果你去过图书馆，应该会知道图书馆的检索系统。图书馆为图书准备了检索目录，包括书名、书号、对应的位置信息，包括在哪个区、哪个书架、哪一层。我们可以通过书名或书号，快速获知书的位置，拿到需要的书

MySQL 中的索引，就相当于图书馆的检索目录，它是帮助 MySQL 系统快速检索数据的一种存储结构。我们可以在索引中按照查询条件，检索索引字段的值，然后快速定位数据记录的位置，这样就不需要遍历整个数据表了。而且，数据表中的字段越多，表中数据记录越多，速度提升越是明显

举个例子：全家某个门店的销售流水表有 400 万条数据，现在我要查看一下商品编号是 100 的商品在 2021-11-26 这一天的销售情况，查询代码如下

```
SELECT quantity, price, datetime FROM 流水表
WHERE date > '2021-11-26' AND date < '2021-11-27' AND itemnumber = 100;
+----------+--------+---------------------+
| quantity | price | date |
+----------+--------+---------------------+
| 1.000 | 220.00 | 2020-11-26 19:45:36 |
| 1.000 | 220.00 | 2020-11-26 08:56:37 |
+----------+--------+---------------------+
2 rows in set (8.08 sec)
```

可以看到结果总共有 2 条记录，可是却花了 8 秒钟，非常慢。同时，这里我没有做表的关联，这只是单表的查询，而且只是一个门店几个月的数据而已。而总部是把所有门店的数据都汇总到一起，查询速度更慢，这样的查询效率，我们肯定是不能接受的

这个时候，我们就可以给数据表添加索引

## 单字段索引

MySQL 支持单字段索引和组合索引，而单字段索引比较常用，我们先来学习下创建单字段索引的方法。如何创建单字字段索引

### 创建单字段索引

* 通过create语句直接给已经存在的表创建索引
* 在创建表的同时创建索引
* 通过修改表来创建索引

直接给数据表创建索引的语法：

```sql
create INDEX 索引名 ON TABLE 表名（字段）
```

创建表的同时创建索引的语法：

```sql
create table 表名
(
    字段 数据类型，
    ......
    {INDEX | KEY} 索引名（字段）
)
```

修改表的同时创建索引的语法：

```sql
alter table 表名 ADD {INDEX | KEY} 索引名（字段）
```

注意：给表设定主键约束或者唯一性约束的时候，MySQL 会自动创建主键索引或唯一性索引

### 单字段索引的作用原理

要知道索引是怎么起作用的，我们需要借助 MySQL 中的 EXPLAIN 这个关键字

EXPLAIN 关键字能够查看 SQL 语句的执行细节，包括表的加载顺序，表是如何连接的，以及索引使用情况等

首先我们有这样一张表和数据

```
itemnumber	barcode	goodsname	price
1	0001	书	0.47
2	0002	笔	0.44
3	0002	胶水	0.19
```

其中`itemnumber`是自增主键，`barcode`是编号，`goodsname`是商品名称，`price`是商品价格

然后我们尝试使用范围搜索

```sql
EXPLAIN select * from goodsmaster where itemnumber > '1' and itemnumber < '4' and goodsname = '书'

+----+-------------+-------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
| id | select_type | table       | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | goodsmaster | NULL       | range | PRIMARY       | PRIMARY | 4       | NULL |    2 |    33.33 | Using where |
+----+-------------+-------------+------------+-------+---------------+---------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

* type=range：表示使用索引查询特定范围的数据记录
* rows=2：表示需要读取的记录数（也就是itemnumber为2和3的记录）
* possible_keys=PRIMARY：表示可选的是主键索引
* key=PRIMARY：确实使用的索引是主键索引
* extra=using where：对sql语句的执行细节做了进一步的解释

通过这个例子我们可以发现，有了索引之后，可以先通过查询索引快速定位，然后再找到对应的数据进行读取，这样就大大提高了查询的速度

### 如何选择索引字段

在上面的查询中，我们是选择主键字段当作索引字段，你可能会问，为什么不选择其他的字段作为索引字段呢？这是因为，itemnumber是作为了一个查询条件，当然我们上面还是用了goodsname作为了查询条件，所以我们也可以给goodsname加上索引

但是建议你在选择索引字段的时候，要选择那些经常被用做筛选条件的字段。这样才能发挥索引的作用，提升检索的效率

## 如何创建组合索引（复合索引）

直接给数据表创建索引的语法：

```sql
create INDEX 索引名 ON TABLE 表名 （字段1，字段2，...）
```

创建表的同时创建索引：

```sql
create table 表名
(
	字段 数据类型，
	......,
	{INDEX | KEY} 索引名（字段1，字段2，...）
)
```

修改表时创建索引：

```sql
ALTER TABLE 表名 ADD { INDEX | KEY } 索引名 (字段1，字段2，...)
```

还是使用上面的表为例

假设我们给`goodsname`和`barcode`都加上索引，我们需要查找的是`goodsname`是`书`，而且编码是`0001`的记录，有了组合索引之后，查询的速度会明显提升

```sql
索引字段
名称		字段				索引类型	索引方法
test	goodsname, barcode	 UNIQUE		BTREE

EXPLAIN select * from goodsmaster where barcode='0001' and goodsname = '书';

+----+-------------+-------------+------------+-------+---------------+------+---------+-------------+------+----------+-------+
| id | select_type | table       | partitions | type  | possible_keys | key  | key_len | ref         | rows | filtered | Extra |
+----+-------------+-------------+------------+-------+---------------+------+---------+-------------+------+----------+-------+
|  1 | SIMPLE      | goodsmaster | NULL       | const | test          | test | 806     | const,const |    1 |   100.00 | NULL  |
+----+-------------+-------------+------------+-------+---------------+------+---------+-------------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)


EXPLAIN select * from goodsmaster where barcode='0001' and goodsname = '书' and itemnumber=1;
+----+-------------+-------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
| id | select_type | table       | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | goodsmaster | NULL       | const | PRIMARY,test  | PRIMARY | 4       | const |    1 |   100.00 | NULL  |
+----+-------------+-------------+------------+-------+---------------+---------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

可以看出来可以作为备选的索引有一个名叫test，然后选择了test作为索引。第二个我们在where条件中加入了主键`itemnumber`的过滤条件，所以会呈现出多个备选索引，如果有多个索引，而这些索引的字段同时作为筛选字段出现在查询中的时候，MySQL 会选择使用最优的索引来执行查询操作

但是，当我们使用上面的联合索引的时候，也能很大程度上优化查询速度

### 组合索引的原理

组合索引的多个字段是有序的，遵循左对齐的原则。比如我们创建的组合索引，排序的方式是`goodsname`和`barcode`，所以筛选的条件也要遵循从左往右的原则，如果终端，那么后面的条件就无法利用索引

```sql
EXPLAIN select * from goodsmaster where barcode='0001';

+----+-------------+-------------+------------+------+---------------+------+---------+------+------+----------+-------------+
| id | select_type | table       | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra       |
+----+-------------+-------------+------------+------+---------------+------+---------+------+------+----------+-------------+
|  1 | SIMPLE      | goodsmaster | NULL       | ALL  | NULL          | NULL | NULL    | NULL |    3 |    33.33 | Using where |
+----+-------------+-------------+------------+------+---------------+------+---------+------+------+----------+-------------+
1 row in set, 1 warning (0.00 sec)

EXPLAIN select * from goodsmaster where goodsname = '书';
+----+-------------+-------------+------------+------+---------------+------+---------+-------+------+----------+-------+
| id | select_type | table       | partitions | type | possible_keys | key  | key_len | ref   | rows | filtered | Extra |
+----+-------------+-------------+------------+------+---------------+------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | goodsmaster | NULL       | ref  | test          | test | 403     | const |    1 |   100.00 | NULL  |
+----+-------------+-------------+------------+------+---------------+------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec)
```

比如上述我们只是用了`barcode`一个字段，可见并没有使用联合索引，再看第二个搜索结果是`goodsname`，符合最左原则，就能够使用联合索引。

如果其中有一个范围，假设我们给price也加入联合索引中，并且将price放置在最左侧，如果你的查询语句变成了这样

```sql
EXPLAIN select * from goodsmaster where price > 1000 and goodsname = '书' and barcode='0001';

+----+-------------+-------------+------------+-------+---------------+------+---------+------+------+----------+--------------------------+
| id | select_type | table       | partitions | type  | possible_keys | key  | key_len | ref  | rows | filtered | Extra                    |
+----+-------------+-------------+------------+-------+---------------+------+---------+------+------+----------+--------------------------+
|  1 | SIMPLE      | goodsmaster | NULL       | range | test          | test | 4       | NULL |    1 |    33.33 | Using where; Using index |
+----+-------------+-------------+------------+-------+---------------+------+---------+------+------+----------+--------------------------+
1 row in set, 1 warning (0.00 sec)
```

如果你的`price>10`并没有找到满足的内容，那么也会中断，后面的索引也无法使用

## 删除索引

如果你要删除索引，就可以用：

```sql
DROP INDEX 索引名 ON 表名;
```

当然， 有的索引不能用这种方法删除，比如主键索引，你就必须通过修改表来删除索引。语法如下：

```sql
ALTER TABLE 表名 DROP PRIMARY KEY；
```

最后，我来跟你说说索引的成本。索引能够提升查询的效率，但是建索引也是有成本的，主要有 2 个方面，一个存储空间的开销，还有一个是数据操作上的开销

* 存储空间的开销，是指索引需要单独占用存储空间
* 数据操作上的开销，是指一旦数据表有变动，无论是插入一条新数据，还是删除一条旧的数据，甚至是修改数据，如果涉及索引字段，都需要对索引本身进行修改，以确保索引能够指向正确的记录

因此，索引也不是越多越好，创建索引有存储开销和操作开销，需要综合考虑